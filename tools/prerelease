#!/usr/bin/env bash
# tools/prerelease — run before tagging a release.
#
# Checks:
#   1. Clean working tree (nothing uncommitted or unpushed)
#   2. Lint (fmt + clippy)
#   3. Tests
#   4. All version strings match across every manifest
#   5. Local version is strictly ahead of PyPI
#   6. Local version is strictly ahead of crates.io (inspectre only)
#   7. Wheel builds cleanly (maturin)

set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

# ── Colours ────────────────────────────────────────────────────────────────
RED='\033[0;31m'; GREEN='\033[0;32m'; CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'

pass()    { printf "  ${GREEN}PASS${RESET}  %s\n" "$1"; }
fail()    { printf "  ${RED}FAIL${RESET}  %s\n" "$1"; FAILED+=("$1"); }
info()    { printf "  ${CYAN}-->${RESET}  %s\n" "$1"; }
section() { printf "\n${BOLD}%s${RESET}\n" "$1"; }

FAILED=()

# ── 1. Git cleanliness ─────────────────────────────────────────────────────
section "Git"

info "checking for uncommitted changes"
if [[ -n "$(git status --porcelain)" ]]; then
    fail "uncommitted changes — commit or stash everything before releasing"
    git status --short | sed 's/^/    /'
else
    pass "working tree clean"
fi

info "checking for unpushed commits"
UPSTREAM="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")"
if [[ -z "$UPSTREAM" ]]; then
    fail "no upstream branch set — run: git push -u origin $(git rev-parse --abbrev-ref HEAD)"
else
    UNPUSHED="$(git log "$UPSTREAM"..HEAD --oneline)"
    if [[ -n "$UNPUSHED" ]]; then
        fail "unpushed commits — push before releasing"
        echo "$UNPUSHED" | sed 's/^/    /'
    else
        pass "all commits pushed"
    fi
fi

# ── 2. Lint ────────────────────────────────────────────────────────────────
section "Lint"

info "cargo fmt --check"
if cargo fmt --all -- --check 2>&1; then
    pass "fmt"
else
    fail "fmt (run 'make fmt' to fix)"
fi

info "cargo clippy"
if cargo clippy --workspace --all-targets -- -D warnings 2>&1; then
    pass "clippy"
else
    fail "clippy"
fi

# ── 3. Tests ───────────────────────────────────────────────────────────────
section "Tests"

info "cargo test"
if cargo test --workspace 2>&1; then
    pass "tests"
else
    fail "tests"
fi

# ── 4. Version alignment ───────────────────────────────────────────────────
section "Version alignment"

extract_toml_version() {
    grep '^version' "$1" | head -1 | sed 's/.*= *"\(.*\)"/\1/'
}

PY_VER=$(extract_toml_version "$ROOT/pyproject.toml")
# Crates use workspace inheritance — read the single source of truth.
CARGO_VER=$(extract_toml_version "$ROOT/Cargo.toml")

printf "    %-30s %s\n" "pyproject.toml"  "$PY_VER"
printf "    %-30s %s\n" "Cargo.toml (workspace)" "$CARGO_VER"

if [[ "$PY_VER" == "$CARGO_VER" ]]; then
    pass "all versions match ($PY_VER)"
else
    fail "version mismatch — pyproject.toml=$PY_VER, Cargo.toml workspace=$CARGO_VER"
fi

# Check that path dependencies in bindings have the correct version pinned.
# crates.io requires explicit versions on path deps.
info "checking path dependency versions"
PATH_DEP_FAIL=0
for toml in "$ROOT/crates/bindings/Cargo.toml"; do
    while IFS= read -r line; do
        # Match lines like: some-crate = { path = "...", version = "x.y.z" }
        if [[ "$line" =~ path\ *=.*version\ *=\ *\"([^\"]+)\" ]]; then
            dep_ver="${BASH_REMATCH[1]}"
            dep_name=$(echo "$line" | sed 's/\s*=.*//')
            if [[ "$dep_ver" != "$CARGO_VER" ]]; then
                fail "path dep '$dep_name' in $(basename $toml) pinned to $dep_ver, expected $CARGO_VER"
                PATH_DEP_FAIL=1
            fi
        elif [[ "$line" =~ ^inspectre.*path\ *= ]]; then
            # path dep exists but has no version — only flag if it's a published crate
            dep_name=$(echo "$line" | sed 's/\s*=.*//' | tr -d ' ')
            if [[ "$dep_name" != "inspectre-bindings" ]]; then
                fail "path dep '$dep_name' in $(basename $toml) is missing a version — crates.io requires one"
                PATH_DEP_FAIL=1
            fi
        fi
    done < "$toml"
done
if [[ $PATH_DEP_FAIL -eq 0 ]]; then
    pass "path dependency versions match workspace ($CARGO_VER)"
fi

# ── 5 & 6. Registry checks ─────────────────────────────────────────────────
section "Registry checks"

version_gt() {
    python3 -c "
import sys
def parse(v):
    return tuple(int(x) for x in v.strip().split('.'))
sys.exit(0 if parse('$1') > parse('$2') else 1)
"
}

info "Checking PyPI (inspectre-sim)"
PYPI_VER=$(curl -sf "https://pypi.org/pypi/inspectre-sim/json" \
    | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['info']['version'])" \
    2>/dev/null || echo "0.0.0")
printf "    %-30s local=%-12s published=%s\n" "PyPI" "$PY_VER" "$PYPI_VER"
if version_gt "$PY_VER" "$PYPI_VER"; then
    pass "pypi: $PY_VER > $PYPI_VER"
else
    fail "pypi: $PY_VER is not ahead of published $PYPI_VER"
fi

check_crate() {
    local crate="$1" local_ver="$2"
    info "Checking crates.io ($crate)"
    local pub_ver
    pub_ver=$(curl -sf "https://crates.io/api/v1/crates/$crate" \
        -H "User-Agent: inspectre-prerelease-check" \
        | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['crate']['newest_version'])" \
        2>/dev/null || echo "0.0.0")
    printf "    %-30s local=%-12s published=%s\n" "$crate" "$local_ver" "$pub_ver"
    if version_gt "$local_ver" "$pub_ver"; then
        pass "crates.io $crate: $local_ver > $pub_ver"
    else
        fail "crates.io $crate: $local_ver is not ahead of published $pub_ver"
    fi
}

check_crate "inspectre" "$CARGO_VER"

# ── 7. Build checks ────────────────────────────────────────────────────────
section "Build checks"

MATURIN="$([ -f "$ROOT/.venv/bin/maturin" ] && echo "$ROOT/.venv/bin/maturin" || command -v maturin 2>/dev/null || echo "")"

# ── Wheels (maturin) ──────────────────────────────────────────────────────
WHEEL_OUT="/tmp/inspectre-check-dist"
rm -rf "$WHEEL_OUT"
mkdir -p "$WHEEL_OUT"

if [[ -n "$MATURIN" ]]; then
    info "maturin build (native)"
    if "$MATURIN" build --release --out "$WHEEL_OUT" 2>&1; then
        pass "maturin wheel (native)"
    else
        fail "maturin wheel build (native)"
    fi

    # Cross-compile aarch64 wheel — requires zig or cross for the linker
    if command -v zig >/dev/null 2>&1 || command -v cross >/dev/null 2>&1; then
        info "maturin build (aarch64-unknown-linux-gnu)"
        if CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \
           "$MATURIN" build --release --target aarch64-unknown-linux-gnu \
                --out "$WHEEL_OUT" 2>&1; then
            pass "maturin wheel (aarch64-unknown-linux-gnu)"
        else
            fail "maturin wheel build (aarch64-unknown-linux-gnu)"
        fi
    else
        info "skipping aarch64 wheel (CI only — zig/cross not found locally)"
    fi
else
    fail "maturin not found — run 'make python' first"
fi

# ── Summary ────────────────────────────────────────────────────────────────
printf "\n"
if [[ ${#FAILED[@]} -eq 0 ]]; then
    printf "${GREEN}${BOLD}All checks passed.${RESET} Ready to tag v%s\n\n" "$PY_VER"
    printf "  git tag v%s && git push origin v%s\n\n" "$PY_VER" "$PY_VER"
    exit 0
else
    printf "${RED}${BOLD}%d check(s) failed:${RESET}\n" "${#FAILED[@]}"
    for f in "${FAILED[@]}"; do
        printf "  ${RED}FAIL${RESET}  %s\n" "$f"
    done
    printf "\n"
    exit 1
fi
